<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Bilibili</title>
    <script src="ind_cpp.js"></script>
    <script src="components.js"></script>
    <!-- 加载组件定义 -->
    <link
      rel="stylesheet"
      href="https://hmos.dongs.xyz/harmonyos_sans_sc.css"
    />
    <style>
      body {
        background-color: rgb(235, 235, 235);
      }

      .component {
        position: absolute;
        border: 1px solid black;
      }

      .fixedElement {
        position: fixed;
        /* border: 1px solid black; */
        background-color: white;
      }

      .text {
        font-family: "HarmonyOS Sans SC", sans-serif;
        white-space: nowrap;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        /* 垂直居中 */
      }

      img {
        width: 100%;
        height: 100%;
      }

      .img.search-icon {
        z-index: 100;
        background-color: aqua;
      }

      .download-button {
        background-color: rgb(225, 225, 225);
        border-radius: 20px;
        color: rgb(52, 88, 252);
        font-size: 15px;
        font-weight: bolder;
      }

      .text.more-text {
        color: grey;
      }

      .text.title {
        font-size: 16px;
        font-weight: 400;
      }

      .text.class {
        font-size: 16px;
        font-weight: 400;
      }

      .text.search-text {
        font-size: 16px;
        color: grey;
        z-index: 1;
      }

      .search-bar {
        background-color: white;
        opacity: 15%;
        position: absolute;
        /* border: 2px solid red; */
        border-radius: 20px;
      }
    </style>
  </head>

  <body>
    <script>
      let moduleInstance = null;
      const elementCache = []; // 使用数组来缓存组件元素

      function initializeComponents(screenWidth) {
        if (!moduleInstance) {
          createModule().then((Module) => {
            moduleInstance = Module;
            const componentNames = moduleInstance.getInitialComponents();
            renderComponents(componentNames);
          });
        } else {
          const componentNames = moduleInstance.getInitialComponents();
          renderComponents(componentNames);
        }
      }

      function renderComponents(componentNames) {
        // 清空现有组件
        elementCache.length = 0; // 清空缓存数组
        for (const key in imageurls) {
          let div = document.createElement("div");
          div.id = key;
          div.className = "component";
          if (key === "search_go") {
            div.classList.add("search-icon");
          }
          const imageurl = imageurls[key];
          const img = new Image();
          img.src = imageurl;
          div.appendChild(img);
          document.body.appendChild(div);
        }
        for (const key in texts) {
          let div = document.createElement("div");
          div.id = key;
          div.className = "component text";
          if (key.includes("install")) {
            div.classList.add("download-button");
          } else if (key.includes("kid_1")) {
            div.classList.add("more-text");
          } else if (key.includes("word")) {
            div.classList.add("title");
          } else if (key.includes("name")) {
            div.classList.add("class");
          } else if (key === "search_bar") {
            div.classList.add("search-text");
          }
          const text = texts[key];
          // div.style.border = "1px solid";
          div.textContent = text[0];
          // div.textContent = text;
          div.style.fontSize = text[1];
          document.body.appendChild(div);
        }
        for (const key in abs_pos) {
          let div = document.createElement("div");
          div.id = key;
          div.className = "fixedElement";
          const info = abs_pos[key];
          if (info.length > 0) {
            if (info[0]) {
              const img = new Image();
              img.src = info[0];
              div.appendChild(img);
            }
            if (info[1]) {
              div.className = "fixedElement text";
              div.textContent = info[1];
            }
          }
          document.body.appendChild(div);
        }
        for (const key in bords) {
          let div = document.createElement("div");
          div.id = key;
          // div.className = "component text";
          // div.className = "search-bar";
          // div.style.border = "1px solid";
          document.body.appendChild(div);
          console.log(key);
        }
        for (let i = 0; i < componentNames.size(); i++) {
          const name = componentNames.get(i);
          const div2 = document.getElementById(name);
          if (!div2) {
            let div = document.createElement("div");
            div.id = name;
            // div.textContent = name;
            div.className = "component text";
            if (name === "search") {
              div.classList.add("search-bar");
            }
            document.body.appendChild(div);
            elementCache.push(div);
          } else {
            elementCache.push(div2);
          }
        }

        updateComponents(window.innerWidth, window.innerHeight);
      }

      function updateComponents(screenWidth, screenHight) {
        const components = moduleInstance.getComponents(
          screenWidth,
          screenHight
        );

        for (let i = 0; i < components.size(); i++) {
          const component = components.get(i);
          const div = elementCache[i]; // 从缓存数组获取组件元素
          div.style.left = component.x + "px";
          div.style.top = component.y + "px";
          div.style.width = component.w + "px";
          div.style.height = component.h + "px";
          div.style.visibility = component.v ? "visible" : "hidden";
        }
      }

      // 获取初始屏幕宽度并初始化组件
      initializeComponents(window.innerWidth);

      // 添加事件监听器，在屏幕宽度变化时实时更新组件
      window.addEventListener("resize", () => {
        updateComponents(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
